{
    "methods": {
        "acceptSubscriptionOwnerTransfer(uint64)": {
            "stateMutability": "nonpayable",
            "code": "function acceptSubscriptionOwnerTransfer(uint64 subId) external nonpayable",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                }
            },
            "outputs": {},
            "notice": "Request subscription owner transfer.",
            "details": "will revert if original owner of subId has not requested that msg.sender become the new owner."
        },
        "addConsumer(uint64,address)": {
            "stateMutability": "nonpayable",
            "code": "function addConsumer(uint64 subId, address consumer) external nonpayable",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                },
                "consumer": {
                    "type": "address",
                    "description": "- New consumer which can use the subscription"
                }
            },
            "outputs": {},
            "notice": "Add a consumer to a VRF subscription."
        },
        "cancelSubscription(uint64,address)": {
            "stateMutability": "nonpayable",
            "code": "function cancelSubscription(uint64 subId, address to) external nonpayable",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                },
                "to": {
                    "type": "address",
                    "description": "- Where to send the remaining LINK to"
                }
            },
            "outputs": {},
            "notice": "Cancel a subscription"
        },
        "createSubscription()": {
            "stateMutability": "nonpayable",
            "code": "function createSubscription() external nonpayable returns (uint64 subId)",
            "inputs": {},
            "outputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- A unique subscription id."
                }
            },
            "notice": "Create a VRF subscription.",
            "details": "You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));"
        },
        "getRequestConfig()": {
            "stateMutability": "view",
            "code": "function getRequestConfig() external view returns (uint16, uint32, bytes32[])",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "uint16",
                    "description": "minimumRequestConfirmations global min for request confirmations"
                },
                "_1": {
                    "type": "uint32",
                    "description": "maxGasLimit global max for request gas limit"
                },
                "_2": {
                    "type": "bytes32[]",
                    "description": "s_provingKeyHashes list of registered key hashes"
                }
            },
            "notice": "Get configuration relevant for making requests"
        },
        "getSubscription(uint64)": {
            "stateMutability": "view",
            "code": "function getSubscription(uint64 subId) external view returns (uint96 balance, uint64 reqCount, address owner, address[] consumers)",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                }
            },
            "outputs": {
                "balance": {
                    "type": "uint96",
                    "description": "- LINK balance of the subscription in juels."
                },
                "reqCount": {
                    "type": "uint64",
                    "description": "- number of requests for this subscription, determines fee tier."
                },
                "owner": {
                    "type": "address",
                    "description": "- owner of the subscription."
                },
                "consumers": {
                    "type": "address[]",
                    "description": "- list of consumer address which are able to use this subscription."
                }
            },
            "notice": "Get a VRF subscription."
        },
        "removeConsumer(uint64,address)": {
            "stateMutability": "nonpayable",
            "code": "function removeConsumer(uint64 subId, address consumer) external nonpayable",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                },
                "consumer": {
                    "type": "address",
                    "description": "- Consumer to remove from the subscription"
                }
            },
            "outputs": {},
            "notice": "Remove a consumer from a VRF subscription."
        },
        "requestRandomWords(bytes32,uint64,uint16,uint32,uint32)": {
            "stateMutability": "nonpayable",
            "code": "function requestRandomWords(bytes32 keyHash, uint64 subId, uint16 minimumRequestConfirmations, uint32 callbackGasLimit, uint32 numWords) external nonpayable returns (uint256 requestId)",
            "inputs": {
                "keyHash": {
                    "type": "bytes32",
                    "description": "- Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost."
                },
                "subId": {
                    "type": "uint64",
                    "description": "- The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash."
                },
                "minimumRequestConfirmations": {
                    "type": "uint16",
                    "description": "- How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200]."
                },
                "callbackGasLimit": {
                    "type": "uint32",
                    "description": "- How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]"
                },
                "numWords": {
                    "type": "uint32",
                    "description": "- The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle."
                }
            },
            "outputs": {
                "requestId": {
                    "type": "uint256",
                    "description": "- A unique identifier of the request. Can be used to match a request to a response in fulfillRandomWords."
                }
            },
            "notice": "Request a set of random words."
        },
        "requestSubscriptionOwnerTransfer(uint64,address)": {
            "stateMutability": "nonpayable",
            "code": "function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external nonpayable",
            "inputs": {
                "subId": {
                    "type": "uint64",
                    "description": "- ID of the subscription"
                },
                "newOwner": {
                    "type": "address",
                    "description": "- proposed new owner of the subscription"
                }
            },
            "outputs": {},
            "notice": "Request subscription owner transfer."
        }
    },
    "events": {},
    "errors": {},
    "path": "k/contracts/src/v0.8/interfaces",
    "name": "VRFCoordinatorV2Interface"
}